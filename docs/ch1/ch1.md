## 리눅스 컨테이너 격리 메커니즘
하나의 리눅스 환경에서 프로세스를 격리할 때 두 가지 메커니즘이 동작한다.

### 리눅스 네임스페이스
리눅스 네임스페이스는 프로세스가 다음과 같은 시스템을 생성하여 독립 적인 환경에서 작동함으로써 컨테이너를 격리한다.
- 마운트(mnt)
- 프로세스(pid)
- 네트워크(network)
- 프로세스 간 통신(ipc)
- 호스트 및 도메인 이름(uts)
- 사용자(user)

### cgroups
네임스페이스가 시스템에 대해 격리 했다면 cgroups는 시스템 자원의 수집 및 제한 하는 기능이다. 시스템 자원은 아래와 같다
- cpu
- memory
- network(대역폭)
- device


### 격리의 장점
리눅스에서 위 두 기능을 사용하여 프로세스를 격리하는 이유는 뭘까? 개인적인 생각으로 장점은 2가지다
1. 격리함으로써 발생하는 문제를 최소화
컨테이너에 문제가 발생한 경우, 문제가 생긴 본인 프로세스만 종료되고 다른 컨테이너에 영향을 끼치지 않는다.
2. 시스템 자원 최소화
컨테이너의 자원 사용량을 제한하여 하나의 컨테이너가 시스템의 모든 자원을 사용하지 못하게 한다.

## 쿠버네티스 클러스트 아키텍쳐
쿠버네티스는 마스터 노드와 워커 노드로 구성되며 이렇게 구성된 환경을 쿠버네티스 클러스터라고 한다.

### 마스터 노드
마스터 노드는 쿠버네티스 시스템 전체를 관리하고 제어함
아래와 같은 구성 요소를 가짐
1. __API 서버(11장)__
쿠버네티스의 구성 요소들과 통신하며 설정 데이터들을 etcd에 저장하고 읽음
2. __etcd__
쿠버네티스 설정 데이터를 (key, value) 형태로 분산 저장
3. __스케줄러(11장)__
애플리케이션 구성 요소(pod)를 워커 노드에 할당
4. __컨트롤러 매니저__
워커 노드를 추적, 장애 처리등 애플리케이션 디스크립션을 통해 정의된 내용으로 유지

### 워커 노드
워커 노드는 실제 배포되는 컨테이너 애플리케이션을 실행함 애플리케이션들은 `Pod`라는 단위로 실행됨
아래와 같은 구성 요소를 가짐
1. __kubelet(11장)__
API 서버와 통신하며 노드의 컨테이너 관리
2. __kube-proxy(11장)__
애플리케이션 구성 요소 간 네트워크 트래픽을 로드 밸런싱
3. __container runtime__
실제 컨테이너를 실행하는 런타임


### ch1을 읽으며 궁금한 내용
1. 도커와 리눅스 컨테이너의 차이
2. 각 쿠버네티스 구성 요소(kubelet, 스케줄러, 컨트롤러 매니저 등)의 역할