### 배포 방식의 변화
쿠버네티스를 살펴보기 전 배포 방식이 어떻게 변해왔는지를 알아야 한다. 아래의 그림은 배포 방식이 어떻게 변화 됐는지 보여준다.
![image](./images/vm_container.svg)
1. __전통적인 배포__
이 배포 방식은 하나의 서버 안에 여러 개의 애플리케이션이 동작된다. 이 방식의 문제는 한 개의 애플리케이션이 많은 양의 자원(cpu, ram)을 사용하면 다른 애플리케이션에 영향을 끼치므로 문제가 발생할 가능성이 높다.
3. __가상화 배포__
전통적인 배포 방식의 문제를 해결하기 위해 가상화를 사용하여 VM안에 애플리케이션을 격리 하여 배포한다.
VM은 가상화된 하드웨어 상에서 자체 __운영체제__ 를 포함한 모든 구성 요소를 가진 머신이다.
하지만 Host OS위에 각 VM별 Guest OS를 가지고 있으므로 추가적인 컴퓨팅 자원이 더 필요하다.
4. __컨테이너 배포__
컨테이너는 VM과 속성이 유사하지만 격리 속성을 완화하여 Host OS에서 애플리케이션들을 격리한다.
Host OS에서 실행되는 격리된 프로세스 처럼 느껴지며 별도의 Geust OS를 가지고 있지 않아 추가적인 오버헤드가 없다.


### 가상머신과 컨테이너는 어떻게 명령을 실행할까?
VM을 사용하든 컨테이너를 사용하든 하나의 물리적인 서버안에 구성되며, 물리서버의 CPU를 사용해 명령을 처리해야한다. 두 기술은 어떻게 CPU에 명령을 전달할까?
1. 가상머신
가상머신은 Host OS에 설치된 하이퍼바이저(vmwaer, virtual box)를 통해 Guest OS를 설치하고 애플리케이션을 실행한다.
애플리케이션이 Geust OS의 시스템 콜을 실행하면, 커널은 하이퍼바이저를 통해 물리 서버에 설치된 cpu에서 명령을 수행한다. 
요약하면 애플리케이션 -> Guest OS 커널 -> 가상  CPU -> 하이퍼바이저 -> 물리 서버 CPU 과정을 통해 명령을 수행한다. 
3. 컨테이너
컨테이너가 시스템 콜을 실행한 경우, 컨테이너 런타임을 통해 Host OS에서 실행되는 커널을 통해 시스템 콜 명령을 수행한다.
애플리케이션 -> container runtime(윈도우의 경우 wsl 사용) -> 물리 서버 CPU 과정을 통해 명령을 수행하며 별도의 운영체제를 가지고 있는 가상 머신에 비해 더 비용이 작고 빠르다.

### 리눅스 컨테이너 격리 메커니즘
그럼 리눅스에선 어떤 기능을 사용하여 어떻게 프로세스들을 격리 하는지 알아보자

### 리눅스 네임스페이스
리눅스 네임스페이스는 프로세스가 다음과 같은 시스템을 생성하여 독립 적인 환경에서 작동함으로써 컨테이너를 격리한다.
(아래에서 말하는 네임스페이스는 컨테이너라고 해석할 수 있다)
- 마운트(mnt)
    - 파일 시스템 마운트 포린트를 격리
    - 각 네임스페이스는 독립적인 마운트 트리(파일시스템)을 가지며, 다른 네임스페이스의 파일 시스템에 영향을 미치지 않는다.
- 프로세스(pid)
    - 프로세스 ID 격리
    - 각 네임스페이스는 자체적인 PID를 가진다.
- 네트워크(network)
    - 네트워크 장치, IP, 포트 번호 격리
    - 각 네임스페이스는 독립적인 네트워크 인터페이스, IP를 사용할 수 있다.
- 프로세스 간 통신(ipc)
    - 프로세스 간 통신 격리
    - 각 네임스페이스는 독립적인 세마포어, 공유 메모리 등을 가진다.
- 호스트 및 도메인 이름(uts)
    - 호스트 이름 및 도메인 이름 격리
    - 각 네임스페이스는 독립적인 호스트 이름과 도메인을 가짐
- 사용자(user)
    - 사용자 및 그룹 격리
    - 각 네임스페이스는 독립적인 사용자와 그룹을 가지며 권한도 분리할 수 있다.

### cgroups
네임스페이스가 시스템에 대해 격리 했다면 cgroups는 시스템 자원을 제한하는 기능이다.
- cpu
    - cpu 사용량을 제어하여 특정 네임스페이스에 대해 cpu 사용을 제한할 수 있다.
- memory
    - 각 네임스페이스별 메모리를 제한할 수 있다.
- network(대역폭)
    - 각 네임스페이스별 송수신되는 대역폭을 제한할 수 있다.
- device
    - 각 네임스페이스별 디바이스에 대한 접근을 제어할 수 있다
    - ex) 특정 네임스페이스는 USB를 사용하지 못함


### 요약 및 격리의 장점
리눅스는 네임스페이스를 통해 프로세스를 격리하고, cgroup을 통해 각 프로세스에서 사용하는 자원을 제한하여 독립된 컨테이너를 사용할 수 있다.

그럼 프로세스를 격리하는 이유는 뭘까? 개인적인 생각으로 장점은 2가지다
1. 격리함으로써 발생하는 문제를 최소화
컨테이너에 문제가 발생한 경우, 문제가 생긴 본인 프로세스만 종료되고 다른 컨테이너에 영향을 끼치지 않는다.
3. 시스템 자원 최소화
컨테이너의 자원 사용량을 제한하여 하나의 컨테이너가 시스템의 모든 자원을 사용하지 못하게 한다.

### 도커랑 리눅스 컨테이너(네임스페이스, cgroup)의 차이
컨테이너 같은 격리 기술을 얘기할 때 대부분 도커라는 얘기가 많이 나온다. 리눅스에서 컨테이너를 격리하는 기능을 배우니 도커랑 그럼 뭐가 다른거지? 라는 생각이 들었다.

먼저 결과적으로 docker는 containerd를 사용하고, containerd는 내부적으로 리눅스 컨테이너 격리 기능을 사용한다.

docker는 내부적으로 containerd 라는 기술을 사용하여 컨테이너를 관리하고 이외에도 개발자에게 유용한 CLI, API를 제공한다.
containerd는 내부적으로 리눅스 컨테이너 격리(네임스페이스, cgroup)기능을 사용해서 만든 컨테이너를 실행할 수 있는 경량 런타임이다.
그래서 도커는 containerd 기술을 사용하면서 개발자가 컨테이너 기능을 사용하기 쉽게 만든 도구이다.


