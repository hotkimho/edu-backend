
## 쿠버네티스 클러스트 아키텍쳐
쿠버네티스는 컨트롤 플레인이라고 부르는 마스터 노드와 실제 애플리케이션을 실행하는 워커 노드로 구성된다.
![image](./images/components-of-kubernetes.svg)
그림을 보면 파란색 점선으로 칠해진 컨트롤 플레인 안에는 API server, controller manager, etcd, scheduler이 있고 api서버랑 통신하는 node(워커 노드)들이 있다.

### 마스터 노드(control plane)
마스터 노드는 클러스터의 전반적인 결정을 수행한다. 스케줄링을 통해 파드를 배치 하거나, replicas 조건에 따라 파드를 늘리는 등 클러스터의 모든 결정을 하며, 이 결정들은 분리된 구성 요소들에 의해 동작한다.

1. __API 서버__
API 서버는 마스터 노드의 핵심 기능으로 대부분의 요청은 API서버를 통해 각 구성 요소들에게 전달된다.
RESTful API를 통해 리소스(파드, 서비스, 시크릿 등)에 접근할 수 있으며, `kubectl`을 통해 RESTful API를 CLI 환경에서 사용할 수 있다.
오직 API 서버를 통해서만 리소스들에 대한 상태, 설정, 메니페스트 들을 etcd에 저장 하고 읽어올 수 있다.
API 서버는 수평 확장이 가능하므로 요청이 많은 경우, 스케일 아웃하여 요청을 분산할 수 있다.

2. __etcd__
클러스터의 데이터를 저장하는 key, value 형태의 저장소이다.
API 서버의 요청이 동시에 오면 동시성 문제가 발생할 수 있지만 `Raft 합의 알고리즘`을 통해 동시성 문제 해결한다.

3. __스케줄러__
스케줄러는 애플리케이션의 배포를 담당한다. 
스케줄러는 API 서버에 배치할 파드가 있는지 주기적으로 요청을 보내며, 노드가 배정되지 않은 파드가 있으면 파드 요구사항에 맞는 노드에 파드를 배치한다.
 
4. __컨트롤러 매니저__
컨트롤러는 여러 개로 분리된 프로세스지만 복잡성을 낮추기 위해 단일 프로세스에서 실행된다.
컨트롤러는 다음과 같이 역할별로 분리되어 있다.
결과적으로 컨트롤러는 특정 리소스를 모니터링하고 그 리소스가 목표 `상태`를 유지하도록 보장한다.

5. __노트 컨트롤러__
클러스터 내의 노트를 모니터링하며, 노드가 다운되었을 때 이를 감지하고 대응한다.

잡 컨트롤러
일회성 작업을 나타내는 잡 오브젝트를 감시하며, 해당 작업이 완료할 때까지 동작하는 파드를 생성
__엔드포인트슬라이스 컨트롤러__
하나의 엔드포인트 리소스에 모든 파드의 IP와 포트 정보가 포함된 걸 `엔드 포인트` 라고 한다 이를 성능과 확장성을 위해 엔드포인트를 분할하여 관리하는걸 `엔드포인트슬라이스`라고 한다.
엔드포인트슬라이스 컨트롤러는 서비스와 파드간 연결을 관리하기 위해 이런 엔드포인트슬라이스를 생성하고 업데이트 한다.
__레플리케이션 컨트롤러__
지정된 수의 파드가 동작하는지 모니터링 하며, 부족하거나 많은 경우 파드를 생성/삭제 한다.


### 워커 노드
워커 노드는 실제 배포되는 컨테이너 애플리케이션을 실행함 애플리케이션들은 `Pod`라는 단위로 실행한다.

1. __kubelet__
파드는 마스터 노드의 API서버 그리고 같은 노드내의 컨테이너 런타임과 통신하며 아래와 같은 다양한 역할을 한다.
- API 서버로 파드 사양을 수신하고, 파드를 노드에서 실행
- 노드와 파드의 상태를 주기적으로 API 서버에 보고
- 노드와 파드 상태를 모니터링하며 `헬스 체크`를 수행
- 파드에서 사용하는 configMap, secret 정보를 API 서버에서 가져와서 해당 파드에 할당

2. __kube-proxy(11장)__
서비스와 연결된 파드간 적절한 부하를 처리하도록 로드밸런싱을 수행한다.
노트의 네트워크 규칙을 유지하고 관리하며, 이 규칙이 내부 네트워크 세션이나 클러스터 바깥 파트로 통신을 할 수 있게 해준다.
3. __container runtime__
컨테이너 생성, 이미지 관리등 컨테이너레 실행되는 기능을 제공한다.
kuberneted CRI 인터페이스를 만족하는 구현체를 지원한다.
